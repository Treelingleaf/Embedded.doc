### 课程内容：

- C++概述
- 命名空间
- 基本输入输出
- C++的函数有什么不一样的
- 引用
- 内管管理

------

### 开场白

大家好，欢迎来到C++。在开始之前，我想先了解一下，大家之前对C++的认识有哪些？

从现在开始，真正进入主课了哈，：）

C++作为C语言的超集，既保留了C语言的许多特性，又添加了一些新的功能，使得编程更加高效和灵活。接下来，我们就来一起探索C++的魅力吧！

## 一：C++概述

C++完全支持C语言，也就是在C语言中的语法在C++中基本都是合法的。

C++的语法结构也是基于C语言的，比如if else、switch、while、for循环，以及struct、static、const等的含义完全一样的。所以完全可以看成跟C是一个整体，是一个语言。

C++是一门非常强大的编程语言，它诞生于上世纪80年代，由Bjarne Stroustrup博士创造。C++不仅继承了C语言的优点，还增加了面向对象编程的特性，使得代码更加易于管理和维护。在现代软件开发中，C++广泛应用于游戏开发、系统编程、科学计算等领域。

与C语言相比，C++提供了更多的功能和灵活性。比如，C++支持类和对象的概念，这使得我们可以更好地组织代码，实现代码的复用和扩展。此外，C++还引入了模板、异常处理等特性，进一步提高了编程的效率和安全性。

从面向过程到面相对象，不仅仅是从struct到class，更是整个编程思想的变化。

大家都是搞过程序的人了，下面以C++对于C的新特性说起。。

## 二：命名空间

在C++中，命名空间（Namespace）是一种将相关的代码、变量、函数和类组织在一起的方式，以避免命名冲突。它提供了一种封装机制，使得相同名称的类、函数或变量在不同的命名空间中不会相互干扰。

命名空间通过关键字 `namespace` 定义。下面是一个简单的例子来说明命名空间的用法：

在例子中，我们定义了一个名为 `MyNamespace` 的命名空间，并在其中定义了一个变量 `x` 和一个函数 `printMessage()`。在 `main()` 函数中，我们使用了作用域解析运算符 `::` 来访问命名空间中的成员。此外，我们还展示了如何使用 `using` 声明和 `using` 指令来简化对命名空间成员的访问。

```cpp
#include <stdio.h>  
  
// 定义一个名为MyNamespace的命名空间  
namespace MyNamespace {  
    int x = 10; // 在命名空间中定义的变量  
  
    void printMessage() {  
        printf() "Hello from MyNamespace!" );  
    }  
}  
  
int main() {  
    // 1.使用命名空间的成员时，可以使用作用域解析运算符(::)  
    printf("%d \n", MyNamespace::x); // 输出：10  
    MyNamespace::printMessage(); // 输出：Hello from MyNamespace!  
  
    // 2.如果不想每次都使用作用域解析运算符，可以使用using声明或using指令  
    using MyNamespace::x; // 引入命名空间中的x变量  
    printf("%d \n", x); // 输出：10 
  
    using MyNamespace::printMessage; // 引入命名空间中的printMessage函数  
    printMessage(); // 输出：Hello from MyNamespace!  
  
    // 3.也可以使用using指令将整个命名空间的内容引入到当前作用域  
    using namespace MyNamespace;  
    printf("%d \n", x); // 输出：10  
    printMessage(); // 输出：Hello from MyNamespace!  
  
    return 0;  
}
```



注意，过度使用 `using namespace` 指令可能会导致命名冲突和代码可读性下降，因此在实际编程中应谨慎使用。



## 三：输入输出

在C++中，输入输出流是非常重要的概念。与C语言使用`printf`和`scanf`进行输入输出不同，C++使用`cin`和`cout`来进行输入输出操作。这两个对象分别对应着标准输入和标准输出流，使得输入输出操作更加简洁和直观。

下面是一个简单的示例程序，演示了如何使用`cin`和`cout`进行输入输出：

在这个示例中，我们首先包含了`iostream`头文件，以便使用输入输出流相关的功能。然后，在`main`函数中，我们使用`cout`输出一条提示信息，告诉用户需要输入一个整数。接着，使用`cin`从标准输入读取一个整数，并将其存储在变量`a`中。最后，再次使用`cout`输出读取到的整数。

```cpp
#include <iostream>  
using namespace std;  
  
int main() {  
    int a;  
    cout << "请输入一个整数："; // 输出提示信息  
    cin >> a; // 从标准输入读取一个整数  
    cout << "你输入的整数是：" << a << endl; // 输出读取到的整数  
    return 0;  
}
```



通过这个示例，我们可以看到C++的输入输出操作比C语言更加简洁和直观。在实际编程中，我们可以根据需要灵活使用`cin`和`cout`进行各种输入输出操作。



## 四：函数

### 	4.1 函数成员化

在C++中，函数可以被封装在类中，作为类的成员函数。这使得代码更加模块化，易于管理和维护。相比之下，C语言的函数是全局的，不依赖于任何特定的类或对象。

### 	4.2 结构体也可以包含函数

C语言的结构体只能包含数据成员（即变量），而不能包含成员函数。因此，C语言的结构体主要用于数据的组合，而不涉及行为或操作。

在C++中，结构体和类几乎可以互换使用，但类默认具有私有成员访问权限，而结构体默认具有公有成员访问权限。

### 	4.3 具有默认参数

函数的默认参数是C++语言的一个特性，默认参数允许你为函数参数指定默认值，这样当调用函数时如果没有提供该参数的值，就会使用默认值。

使用默认参数的好处是，你可以为函数提供多种调用方式，增加了代码的灵活性和可读性。

下面是一个使用C++默认参数的简单例子：

在例子中，`printGreeting` 函数有两个参数：`name` 和 `times`，它们都有默认值。在 `main()` 函数中，我们展示了三种不同的调用方式：

1. 不提供任何参数，此时 `name` 和 `times` 都会使用默认值。
2. 只提供 `name` 参数，此时 `times` 会使用默认值。
3. 提供 `name` 和 `times` 两个参数，此时都不会使用默认值。

```cpp
#include <iostream>  
  
// 定义一个带有默认参数的函数  
void printGreeting(const char* name = "World", int times = 1) {  
    for (int i = 0; i < times; ++i) {  
        printf( "Hello, %s ！\n", name);  
    }  
}  
  
int main() {  
    // 调用printGreeting函数，使用默认参数  
    printGreeting(); // 输出：Hello, World!  
  
    // 调用printGreeting函数，只提供name参数  
    printGreeting("Alice"); // 输出：Hello, Alice!  
  
    // 调用printGreeting函数，提供name和times参数  
    printGreeting("Bob", 3); // 输出：Hello, Bob! 三次  
  
    return 0;  
}
```



需要注意的是：

- 默认参数只能出现在函数声明的尾部，也就是说，所有带默认值的参数后面都不能有不带默认值的参数。
- 默认参数可以在函数声明时指定，也可以在函数定义时指定，但通常建议在函数声明时指定，这样可以让调用者清楚地看到哪些参数有默认值。
- 如果在函数声明和定义中都指定了默认参数，那么它们必须一致。

默认参数是一个很好的特性，它可以使你的API更加灵活和易于使用，但也需要谨慎使用，避免过多的默认参数导致函数接口变得复杂和难以理解。



### 4.4 函数对象(使用了运算符重载 )- 且当认识

在C++中，函数对象（Function Objects），也被称为仿函数（Functors）或委托（Delegates），是重载了`operator()`的对象，使得它们可以像函数一样被调用。这提供了一种比函数指针更灵活的方式来定义和操作可调用对象。函数对象可以是类的实例，这些类定义了`operator()`，用于执行特定的操作。

下面是一个简单的函数对象的例子：

在这个例子中，`PrintInt`是一个函数对象类，它重载了`operator()`来接受一个`int`类型的参数并打印它。然后，在`main`函数中，我们使用`std::for_each`算法和`PrintInt`函数对象来遍历并打印`vector<int>`中的每个元素。注意，我们传递了`PrintInt()`（即函数对象的临时实例）给`std::for_each`，而不是类名本身。

```cpp
#include <iostream>  
#include <vector>  
#include <algorithm>  
using namespace std; 

// 定义一个函数对象，用于打印整数值  
class PrintInt {  
public:  
    void operator()(int value) const {  
        cout << value << " ";  
    }  
};  
  
int main() {  
    vector<int> numbers = {1, 2, 3, 4, 5};  
      
    // 使用算法std::for_each和函数对象PrintInt来打印vector中的每个元素  
    for_each(numbers.begin(), numbers.end(), PrintInt());  
      
    // 输出换行符，使输出更整洁  
    cout << endl;  
      
    return 0;  
}
```



函数对象比函数指针更强大，因为它们可以包含状态（即类的成员变量），并且可以通过构造函数的参数来配置其行为。此外，它们还支持更复杂的操作，例如模板元编程和操作符重载，这使得它们在某些情况下比简单的函数指针更加适用。

除了上面的例子外，函数对象还经常用于自定义比较器（用于排序和搜索算法）、自定义迭代器、以及任何需要可调用对象的地方。通过使用函数对象，我们可以创建更加灵活和可重用的代码。



## 五： 引用

在 C++ 中，引用（Reference）是一个已存在变量的别名，它提供了变量的另一种访问方式。引用必须在声明时被初始化，并且一旦与某个变量关联起来，就不能再指向其他变量。引用在底层实现上通常是通过指针实现的，但在使用上却表现得像另一个变量名，可以直接通过引用访问和修改它所引用的变量的值。

使用引用有几个好处：

1. 可以作为函数参数，避免拷贝大型对象，提高性能。
2. 可以作为函数返回值，返回对内部数据的引用，而不是数据的拷贝。
3. 可以使代码更加清晰易读，通过有意义的引用名来替代复杂的表达式或变量名。

下面是一个简单的代码示例，演示了 C++ 中的引用概念：

在这个示例中，我们创建了一个整型变量 `a`，并声明了一个引用 `ref`，将其初始化为 `a` 的别名。然后我们通过引用 `ref` 访问和修改了 `a` 的值。注意，尝试重新初始化引用 `ref` 指向另一个变量 `b` 会导致编译错误，因为引用一旦初始化后就不能再指向其他对象。

```cpp
#include <iostream>  
  
int main() {  
    int a = 10;  
    int& ref = a; // 声明一个引用 ref，并初始化为变量 a的别名  
  
    std::cout << "a = " << a << std::endl; // 输出 a的值  
    std::cout << "ref = " << ref << std::endl; // 输出ref的值，即a的值  
  
    ref = 20; // 修改ref的值，实际上也修改了a的值  
    std::cout << "a after modification = " << a << std::endl; // 输出修改后的a的值  
  
    // 尝试重新初始化引用会导致编译错误  
    // int b = 30;  
    // ref = b; // 错误：引用一旦初始化后，就不能再指向其他对象  
  
    return 0;  
}
```



**将我们之前用过的交换数据的函数用引用实现**

下面是一个使用引用来交换两个整型变量的函数的示例，以及一个调用该函数的示例：

在这个示例中，`swapIntegers` 函数接受两个整型引用作为参数。函数内部创建了一个临时变量 `temp` 来保存 `a` 的值，然后将 `b` 的值赋给 `a`，最后将 `temp`（即原来 `a` 的值）赋给 `b`。这样，`a` 和 `b` 的值就被交换了。

```cpp
#include <iostream>  
  
// 交换两个整型变量的函数，使用引用作为参数  
void swapIntegers(int& a, int& b) {  
    int temp = a;  
    a = b;  
    b = temp;  
}  
  
int main() {  
    int x = 5;  
    int y = 10;  
  
    std::cout << "Before swap: x = " << x << ", y = " << y << std::endl;  
  
    // 调用交换函数  
    swapIntegers(x, y);  
  
    std::cout << "After swap: x = " << x << ", y = " << y << std::endl;  
  
    return 0;  
}
```



在 `main` 函数中，我们创建了两个整型变量 `x` 和 `y`，并输出它们的初始值。然后调用 `swapIntegers` 函数来交换 `x` 和 `y` 的值，并再次输出它们的值以验证交换是否成功。

当你运行这个程序时，你会看到输出如下：

```
Before swap: x = 5, y = 10  
After swap: x = 10, y = 5
```

这证明了 `swapIntegers` 函数成功地使用了引用参数来交换了两个变量的值。



## 六： 动态内存管理

### 	6.1 C++内存的申请和释放

在C++中，我们通常使用`new`和`delete`运算符来进行动态内存管理。动态内存分配允许我们在程序运行时根据需要分配和释放内存空间。

使用`new`运算符可以动态地分配内存并返回指向该内存的指针。例如：

```cpp
Class* obj = new Cless();
int* dynamicArray = new int[10]; // 分配一个包含10个整数的数组
```

当我们不再需要这块内存时，应该使用`delete`或`delete[]`运算符来释放它，以防止内存泄漏：

```cpp
delete obj;
delete[] dynamicArray; // 释放动态分配的数组内存
```

动态内存管理使得我们可以创建大小可变的数据结构，并在需要时扩展或缩小它们的容量。然而，动态内存管理也带来了一定的风险，如内存泄漏、野指针等问题，因此在使用时需要格外小心。

### 	6.2 动态内存管理的风险与策略

动态内存管理虽然提供了很大的灵活性，但也带来了一些风险，如内存泄漏和野指针。

**内存泄漏**发生在程序员忘记释放之前分配的内存时。这会导致程序占用的内存持续增长，最终可能导致程序崩溃或系统资源耗尽。为了避免内存泄漏，我们应该在不再需要动态分配的内存时立即使用`delete`或`delete[]`释放它。

**野指针**是指那些指向已经被释放的内存的指针。这些指针仍然保留原来的地址值，但是它们所指向的内存可能已经被其他程序或操作系统重新分配。使用野指针可能会导致不可预测的行为，包括程序崩溃和数据损坏。为了避免野指针，我们应该在释放内存后立即将指针设置为`nullptr`。

为了更有效地管理动态内存，一些策略包括：

- **RAII（Resource Acquisition Is Initialization）**：这是一种编程技术，它强调在对象构造时获取资源（如动态内存），并在对象析构时释放资源。这通过封装资源的生命周期来简化内存管理。
- **智能指针**：C++11及以后的版本提供了智能指针，如`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`，它们能够自动管理动态分配的内存的生命周期，从而减少了内存泄漏和野指针的风险。

### 6.3 内存的存放区域

在C++中，内存主要被分为几个不同的区域，这些区域根据其使用方式和生命周期进行管理。主要有栈区（stack）、堆区（heap），以及其他的内存空间，如全局/静态存储区（global/static storage）和代码区（code or text segment）。

1. **栈区（Stack）**：
   - 栈区主要用于存储局部变量和函数调用的信息（包括返回地址、参数等）。
   - 栈内存分配和释放是自动的，由编译器管理。当函数被调用时，它的局部变量会被推送到栈上；当函数返回时，这些变量会被自动从栈上弹出。
   - 栈内存的大小在程序运行期间是固定的，通常较小，并且每个线程都有其自己的栈。
2. **堆区（Heap）**：
   - 堆区用于动态内存分配，通常通过`new`和`delete`操作符（或`malloc`和`free`函数）来管理。
   - 堆内存的生命周期由程序员控制，必须显式地分配和释放。
   - 堆内存的大小在程序运行期间可以动态地增加或减少。
3. **全局/静态存储区（Global/Static Storage）**：
   - 全局变量和静态变量（包括全局静态变量和局部静态变量）存储在这个区域。
   - 这些变量的生命周期是整个程序的执行期间。
   - 全局变量和静态变量的初始化发生在程序开始执行之前。
4. **代码区（Code or Text Segment）**：
   - 代码区存放程序执行的机器代码，包括编译后的二进制指令。
   - 这部分内存是只读的，防止程序意外地修改其指令。

除了上述的主要内存区域外，还有一些其他的内存区域，如常量区（用于存储常量字符串和其他常量值），以及可能由特定编译器或操作系统管理的其他区域。

了解这些内存区域和其管理方式对于编写高效且安全的C++代码至关重要。不正确地管理内存（例如，忘记释放动态分配的内存或访问已释放的内存）可能导致内存泄漏、程序崩溃或其他未定义行为。



###  6.4 总结

指针和动态内存管理是C++编程中的高级主题，它们提供了对内存的直接控制和更大的灵活性。然而，这也增加了编程的复杂性和出错的可能性。因此，在使用指针和动态内存管理时，我们必须格外小心，并遵循良好的编程实践来确保程序的正确性和安全性。



##  作业题

### 作业题一：命名空间的使用

**题目描述**：
编写一个C++程序，其中包含两个命名空间`NamespaceA`和`NamespaceB`。每个命名空间都包含一个函数`printMessage`，该函数打印一条消息。在`main`函数中，使用这两个命名空间中的`printMessage`函数，并确保不会发生命名冲突。

**示例代码框架**：

```cpp
// 你的代码将在这里开始  
  
namespace NamespaceA {  
    void printMessage() {  
        // 实现代码  
    }  
}  
  
namespace NamespaceB {  
    void printMessage() {  
        // 实现代码  
    }  
}  
  
int main() {  
    // 调用NamespaceA和NamespaceB中的printMessage函数  
    // ...  
    return 0;  
}
```

**要求**：

1. 在`main`函数中，通过适当的方式（例如使用`using`声明或完全限定名）来调用两个命名空间中的`printMessage`函数。
2. 每个`printMessage`函数应打印不同的消息，以区分它们来自哪个命名空间。

### 作业题二：基本输入输出与引用

**题目描述**：
编写一个C++程序，该程序定义一个函数`doubleValue`，该函数接受一个整数的引用作为参数，并将该整数的值翻倍。然后在`main`函数中，声明一个整数变量，将其值设置为5，调用`doubleValue`函数，并打印出修改后的整数值。

延伸：可以考虑将上面函数的参数改成默认参数，看看会有什么结果；

**示例代码框架**：

```cpp
// 你的代码将在这里开始  
  
// 自己定一个函数`doubleValue`，并实现参数定义和逻辑
  
int main() {  
    int value = 5;  
    // 调用doubleValue函数  
    // ...  
    // 打印出修改后的value  
    // ...  
    return 0;  
}
```

**要求**：

1. `doubleValue`函数应该通过引用修改传入的整数值。
2. 在`main`函数中打印出修改后的`value`变量，以验证`doubleValue`函数是否按预期工作。

### 作业题三：动态内存管理

**题目描述**：
编写一个C++程序，该程序定义一个结构`Student`，包含`name`和`age`两个数据成员。在`main`函数中，使用`new`操作符动态创建一个`Student`实例，并为其成员赋值。然后，使用`delete`操作符释放该对象所占用的内存。

如果创建10个学生的数据，继续按照上面要求完成10个学生数组的创建实例、赋值和释放，请注意释放的区别；

**示例代码框架**：

```cpp
// 你的代码将在这里开始  
  
struct Student {  
public:  
    std::string name;  
    int age;  
};  
  
int main() {  
    // 使用new操作符动态创建Student对象  
    // ...  
    // 为Student对象的成员赋值  
    // ...  
    // 使用delete操作符释放Student对象所占用的内存  
    // ...  
    
    // 使用new操作符动态创建10个Student对象  
    // ...  
    // 为其中某几个Student对象的成员赋值  
    // ...  
    // 释放Student对象所占用的内存  请注意与上面释放方式的区别
    // ...  
    return 0;  
}
```

**要求**：

1. 在`main`函数中，使用`new`操作符创建`Student`对象，并通过合适的成员访问操作符（`.`或`->`）为其成员变量`name`和`age`赋值。
2. 在使用完`Student`对象后，确保使用`delete`操作符释放其占用的内存。

