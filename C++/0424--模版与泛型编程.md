课程内容

- 了解模版编程的结构
- 掌握基础的模版编程
- 了解泛型编程的基本思想

## 第七章： C++模版与泛型编程

### 7.1 引言

在C++中，模板和泛型编程是两种强大的编程技术，它们允许我们编写更加通用和灵活的代码。通过模板和泛型编程，我们可以创建可以处理多种数据类型的函数和类，从而提高了代码的重用性和可维护性。

### 7.2 模板基础

模板是C++中用于实现泛型编程的一种工具，它允许程序员编写与具体数据类型无关的代码，从而提高代码的复用性和灵活性。

模板是一种特殊的工具，它接受一个或多个类型参数，并生成基于这些参数的具体函数或类。C++提供了函数模板和类模板两种形式。

#### 7.2.1 函数模板

函数模板允许我们编写可以处理任意类型的函数。例如：

在代码中，`add`是一个函数模板，它接受两个类型为`T`的参数，并返回类型为`T`的结果。在`main`函数中，我们分别用整数和浮点数调用了`add`函数，编译器会根据实参类型自动推断并生成相应的函数实例。

```cpp
template <typename T> // 声明一个类型参数T  
T add(T a, T b) { // 使用类型参数T作为函数参数和返回类型  
    return a + b;  
}  
  
int main() {  
    int x = 5, y = 10;  
    cout << "Sum of integers: " << add(x, y) << endl; // 调用函数模板，T被替换为int  
  
    double a = 1.5, b = 2.5;  
    cout << "Sum of doubles: " << add(a, b) << endl; // 调用函数模板，T被替换为double  
    return 0;  
}
```



#### 7.2.2 类模板

类模板允许我们创建可以处理任意类型的类。例如：

在这个例子中，`Array`是一个类模板，它用于创建一个可以存储任意类型元素的数组。我们定义了构造函数和`print`方法来初始化数组和打印其内容。在`main`函数中，我们分别用整数和浮点数数组创建了`Array`对象，并调用了`print`方法来输出数组的内容。

```cpp
template <typename T>  
class Array {  
private:  
    T* arr;  
    int size;  
  
public:  
    Array(T arr[], int s);  
    void print();  
    // ... 其他方法 ...  
};  
  
template <typename T>  
Array<T>::Array(T arr[], int s) {  
    size = s;  
    this->arr = new T[s];  
    for (int i = 0; i < size; i++) {  
        this->arr[i] = arr[i];  
    }  
}  
  
template <typename T>  
void Array<T>::print() {  
    for (int i = 0; i < size; i++) {  
        cout << arr[i] << " ";  
    }  
    cout << endl;  
}  
  
int main() {  
    int intArr[] = {1, 2, 3, 4, 5};  
    Array<int> intArray(intArr, 5);  
    intArray.print(); // 输出整数数组  
  
    double doubleArr[] = {1.1, 2.2, 3.3, 4.4};  
    Array<double> doubleArray(doubleArr, 4);  
    doubleArray.print(); // 输出浮点数数组  
    return 0;  
}
```



### 7.3 模版的作用

函数模板在解决不同类型数据操作问题上的优势主要体现在其通用性和代码复用性上。通过定义函数模板，我们可以编写一份代码来处理多种类型的数据，而无需为每种类型都编写特定的函数。

以上面函数模版Add函数为例。。。再看一遍

*在这个例子中，我们定义了一个名为 `Add` 的函数模板，它接受两个类型为 `T` 的参数，并返回它们的和。在 `main` 函数中，我们分别使用 `int` 和 `double` 类型调用了 `Add` 函数，编译器自动为我们生成了对应类型的函数实例。*

如果我们继续对二维坐标点求和?

示例如下：

```cpp
// 继续上面的函数模版。。。
template <typename T> // 声明一个类型参数T  
T add(T a, T b) { // 使用类型参数T作为函数参数和返回类型  
    return a + b;  
}  
  
int main() {  
    int x = 5, y = 10;  
    cout << "Sum of integers: " << add(x, y) << endl; // 调用函数模板，T被替换为int  
  
    double a = 1.5, b = 2.5;  
    cout << "Sum of doubles: " << add(a, b) << endl; // 调用函数模板，T被替换为double  
    // return 0;  
    
    // 使用自定义类型（例如结构体）  
    struct Point {  
        int x;  
        int y;  
  
        Point operator+(const Point& other) const {  
            return {x + other.x, y + other.y};  
        }  
    };  
  
    Point p1{1, 2};  
    Point p2{3, 4};  
    Point sumPoint = Add(p1, p2); // 调用Add<Point>的实例，这里假设Point已经重载了+操作符  
    std::cout << "Sum of points: (" << sumPoint.x << ", " << sumPoint.y << ")" << std::endl; // 输出：Sum of points: (4, 6)  
  
    return 0;  
}
```



通过函数模板，我们避免了为每种数据类型编写单独的加法函数，减少了代码量，提高了代码的可读性和可维护性。同时，这也使得我们的代码更加灵活，能够轻松处理未来可能出现的其他数据类型，而无需进行额外的修改。这就是函数模板在解决不同类型数据操作问题上的优势所在。



### 7.4 模版实现的底层逻辑 



编译器根据具体的参数类型来生成函数模板的实例的过程，实际上涉及了模板的实例化和类型推导两个主要步骤。

#### **7.4 1 示例解释**（以上面函数模版为例）

```cpp
template <typename T> // 声明一个类型参数T  
T add(T a, T b) { // 使用类型参数T作为函数参数和返回类型  
    return a + b;  
}  
  
int main() {  
    int x = 5, y = 10;  
    cout << "Sum of integers: " << add(x, y) << endl; // 调用函数模板，T被替换为int  
  
    double a = 1.5, b = 2.5;  
    cout << "Sum of doubles: " << add(a, b) << endl; // 调用函数模板，T被替换为double  
    return 0;  
}
```

首先，我们需要了解函数模板的基本格式，如 `template<typename T>`，这里的 `T` 是一个占位符类型，它表示这个函数模板可以接受任何类型作为参数。

在调用函数模板时，编译器会进行类型推导。这个过程是根据传入的实际参数类型来确定模板参数 `T` 的具体类型。例如，如果我们有一个函数模板 `add`，并且我们这样调用它：`add(a, b);` 其中 `a` 和 `b` 都是 `int` 类型的变量，那么编译器就会推导出 `T` 的类型为 `int`。

接下来是模板的实例化过程。这个过程发生在编译阶段。一旦编译器通过类型推导确定了模板参数的具体类型，它就会生成一个对应类型的函数实例。这个实例就像一个普通的、非模板的函数，其参数类型和返回类型都已经被明确指定。在我们的 `add` 函数模板例子中，编译器会生成一个 `int` 类型的 `add` 函数实例。

这个实例化过程可以是隐式的，也可以是显式的。隐式实例化是编译器自动进行的，我们只需要像上面那样调用函数模板即可。而显式实例化则需要我们在调用函数模板时明确指定模板参数的类型，如 `add<int>(a, b);`。这种方式在某些需要精确控制类型的情况下可能会更有用。

值得注意的是，如果模板参数类型与函数模板中定义的参数类型不匹配，编译器会尝试进行隐式类型转换。但是，如果转换失败或者没有合适的转换，编译器就会报错。

总的来说，编译器根据具体的参数类型来生成函数模板的实例，是一个涉及类型推导和模板实例化的过程。这个过程保证了函数模板的灵活性和类型安全性，使得我们可以编写出更加通用和可重用的代码。

#### 7.4 1 举例说明

下面是一个使用C++函数模板的简单示例，并详细说明了编译器如何根据具体参数类型来生成函数模板的实例。

首先，我们定义一个函数模板：

在这个例子中，`Swap` 是一个函数模板，它接受两个类型为 `T` 的引用参数，并交换它们的值。

```cpp
template <typename T>  
void Swap(T& a, T& b) {  
    T temp = a;  
    a = b;  
    b = temp;  
}
```



接下来，我们看几个使用这个函数模板的例子，并解释编译器如何根据参数类型生成函数实例：

**示例1：使用int类型**

在这个例子中，我们调用了 `Swap` 函数，并传入了两个 `int` 类型的变量 `x` 和 `y`。编译器会进行类型推导，并确定 `T` 的类型为 `int`。然后，编译器生成一个 `Swap<int>` 的函数实例，并在调用时使用该实例。

```cpp
int main() {  
    int x = 5;  
    int y = 10;  
    Swap(x, y); // 编译器生成Swap<int>的实例  
    std::cout << "x: " << x << ", y: " << y << std::endl; // 输出：x: 10, y: 5  
    return 0;  
}
```



**示例2：使用double类型**

在这个例子中，我们调用了 `Swap` 函数，并传入了两个 `double` 类型的变量 `a` 和 `b`。同样地，编译器会进行类型推导，并确定 `T` 的类型为 `double`。然后，编译器生成一个 `Swap<double>` 的函数实例，并在调用时使用该实例。

```cpp
int main() {  
    double a = 3.14;  
    double b = 2.71;  
    Swap(a, b); // 编译器生成Swap<double>的实例  
    std::cout << "a: " << a << ", b: " << b << std::endl; // 输出：a: 2.71, b: 3.14  
    return 0;  
}
```



**显式实例化**

虽然编译器通常能够自动推导模板参数的类型，但在某些情况下，你可能想要显式地指定模板参数的类型。这可以通过在调用函数模板时提供类型参数来完成：

在代码中，尝试显式地将 `Swap` 函数模板实例化为 `Swap<double>` 并传入一个 `int` 类型的变量 `m` 和一个 `double` 类型的变量 `n` 将会导致编译错误，因为类型不匹配。如果要使代码工作，你需要确保所有参数的类型都与显式指定的模板参数类型相匹配，或者进行显式的类型转换。

```cpp
int main() {  
    int m = 1;  
    double n = 2.0;  
    Swap<double>(m, n); // 编译错误：类型不匹配  
    Swap<double>(static_cast<double>(m), n); // 显式转换m的类型可以工作  
    return 0;  
}
```



通过这些示例，你可以看到编译器是如何根据传递给函数模板的实际参数类型来生成函数实例的。每个独特的参数类型组合都会导致生成一个新的函数实例。这就是泛型编程的强大之处，它允许我们编写灵活且可重用的代码。

### 7.5 特化与偏特化

在C++中，模板特化（Template Specialization）和偏特化（Partial Specialization）是两种用于定制模板行为的技术，使得模板能够为特定的类型或类型组合提供特定的实现。这增加了模板的灵活性和可定制性。

#### 7.5.1 模板特化

模板特化是当模板需要对某种特定类型进行特殊处理时使用的技术。你可以为特定的类型参数提供模板的特定版本。

一般在与普通模版同时使用。

**示例**

假设我们有一个简单的模板，用于计算两个值的和：

```cpp
template <typename T>  
T add(T a, T b) {  
    return a + b;  
}
```

现在，假设我们想要为`string`类型特化这个模板，以执行字符串的连接而不是数值加法：

```cpp
template <>  
string add<string>(string a, string b) {  
    return a + b;  
}
```

在这个例子中，当`add`函数使用`string`类型时，它将执行字符串连接而不是数值加法。

#### 7.5.2 偏特化

偏特化是当模板有多个类型参数，并且我们想要为这些类型参数的特定组合提供特定实现时使用的技术。

**示例**

考虑一个模板，它接受两个类型参数`T1`和`T2`：

```cpp
template <typename T1, typename T2>  
class Pair {  
public:  
    T1 first;  
    T2 second;  
      
    Pair(T1 f, T2 s) : first(f), second(s) {}  
      
    void print() {  
        std::cout << "General Pair" << std::endl;  
    }  
};
```

现在，假设我们想要为`int`和`double`类型的组合提供特定的`print`方法实现：

```cpp
template <typename T2>  
class Pair<int, T2> {  
public:  
    int first;  
    T2 second;  
      
    Pair(int f, T2 s) : first(f), second(s) {}  
      
    void print() {  
        std::cout << "Specialized Pair for int and any T2" << std::endl;  
    }  
};
```

在这个例子中，只有当`Pair`的第一个类型为`int`时，才会使用特化的`print`方法。对于其他类型组合，将使用默认的`print`方法。

需要注意的是，偏特化必须至少对一个类型参数进行特化，不能对所有的类型参数都使用默认类型进行偏特化。

模板特化和偏特化是C++模板编程中强大的工具，它们允许程序员为特定的类型或类型组合提供定制的行为，从而增加了代码的灵活性和可重用性。



模板特化是一种为特定类型提供模板的定制版本的技术。特化可以是全特化（针对所有类型参数都进行特化）或偏特化（只针对部分类型参数进行特化）。

```cpp
template <> // 全特化，指定类型参数  
class Array<bool> {  
    // ... 为bool类型特化的实现 ...  
};  
  
template <typename T1, typename T2> // 偏特化示例  
class Pair {  
    // ... 通用实现 ...  
};  
  
template <typename T> // 偏特化，当两个类型相同时  
class Pair<T, T> {  
    // ... 当两个类型相同时的特化实现 ...  
};
```



### 7.6 模板元编程

#### 7.6.1 模版元编程实例

模板元编程是利用模板在编译时进行复杂计算和操作的技术。它通常涉及到模板特化和递归模板展开等技术。虽然模板元编程可以提供极大的灵活性和性能优化，但其语法和理解难度也相对较高。

例如，一个简单的模板元编程实现计算阶乘的例子：

在这个例子中，我们定义了一个模板结构体`Factorial`，它使用递归模板的方式在编译时计算阶乘。特化版本`Factorial<0>`提供了递归的基准情况。这样，当我们询问`Factorial<5>::value`时，编译器会在编译时展开模板并计算出结果。  

```cpp
template <int N>  
struct Factorial {  
    enum { VAL = N * Factorial<N - 1>::VAL };  
};  
  
template <>  
struct Factorial<0> {  
    enum { VAL = 1 };
};

int main() {
    cout << "5! = " << Factorial<5>::VAL << endl; // 输出 5! = 注意：这里只能是常量
    return 0;
}
```



#### **7.6.2 关于模板元编程的作用**

模板元编程是一种利用模板特性在编译期进行编程的技术，它的应用场景广泛且作用显著。以下是一些主要的应用场景：

1. **代码生成**：模板元编程可以根据特定的规则和条件在编译时生成代码，从而创建重复的代码结构，如循环、递归、数据结构的初始化等。这可以提高编程效率，减少手动编写重复代码的工作量。
2. **多态性和泛型编程**：模板元编程支持多态性和泛型编程，使得代码能够适应不同类型和数据结构。通过使用模板，可以编写通用的代码片段，提高代码的可重用性和灵活性。
3. **元对象和反射**：模板元编程可以用于创建和操作元对象（即关于对象的对象），包括类型信息、成员访问、函数调用等。通过元对象和反射，可以在运行时获取和操作对象的元数据，使编程更加动态和灵活。
4. **性能优化**：模板元编程可以在编译期间生成高度优化的代码，从而提高程序的运行效率。这是因为模板运算和展开都在编译期进行，虽然这可能会增加编译时间，但可以获得更有效的运行代码。

总的来说，模板元编程在编程中扮演着重要角色，特别是在需要处理复杂类型操作、提高代码复用性和性能的场景中。然而，模板元编程也具有一定的学习曲线，需要深入理解**编译原理和模板语言**。因此，在使用模板元编程时，需要权衡其带来的好处和可能的学习成本。

### 7.7 泛型编程

C++ 的泛型编程（Generic Programming）是一种编程思想，它强调编写与数据类型无关的代码，即代码可以作用于多种数据类型，而不仅仅是某一特定的数据类型。这种思想使得代码更加灵活、可重用，并减少了冗余。泛型编程的核心在于模板（Templates），它允许程序员定义与类型无关的函数和类，然后在编译时根据具体的类型来生成相应的代码。

这个思想其实有两个层面，1、编写与数据类型无关的代码；2、使用模版元；

#### 7.7.1 泛型编程的主要特点：

1. **类型无关性**：泛型编程的代码不依赖于特定的数据类型。
2. **代码重用**：通过泛型编程，可以编写一次代码并在多种类型上重用。
3. **编译时类型检查**：模板在编译时根据所提供的类型生成代码，这提供了强大的类型安全性。

泛型编程（Generic Programming）是一种编程范式，它允许程序员编写与数据类型无关的通用代码。这种思想的核心在于，通过抽象化数据类型，我们可以创建出更加灵活和可重用的代码结构。在C++中，泛型编程主要通过模板（Templates）来实现。

#### 1. 泛型编程的优势

通过泛型编程，我们可以减少代码冗余，提高代码复用率。因为泛型代码是类型无关的，所以它可以作用于多种数据类型，而无需为每种数据类型都编写一份特定的代码。

#### 2. 泛型编程与面向对象编程的区别

OOP强调通过类和对象来组织代码，而泛型编程则更侧重于编写与类型无关的通用代码。泛型编程并不排斥OOP，相反，它可以在OOP的基础上进一步提高代码的复用性和灵活性。

#### 3. 泛型编程的应用场景

在编写算法库、容器类库、数学库等通用库时，泛型编程可以大大提高代码的可重用性。此外，在编写跨平台、跨语言的代码时，泛型编程也可以发挥重要作用。

#### 4. 进阶示例：STL中的泛型编程

C++标准模板库（STL）中的泛型编程应用。

STL提供了大量的泛型容器（如vector、list、map等）和算法（如sort、find等），这些容器和算法都是通过模板实现的，因此可以作用于多种数据类型。

例如，STL中的`std::sort`函数可以对任意类型的序列进行排序，只要该类型支持比较操作。这意味着我们可以用`std::sort`来对整数数组、浮点数数组、字符串数组甚至自定义类型的对象数组进行排序，而无需为每种类型都编写一个特定的排序函数。

#### 5. 泛型编程的未来趋势

随着编程语言的不断发展和优化，泛型编程的应用范围也在不断扩大。越来越多的库和框架开始采用泛型编程思想来提高代码的可重用性和灵活性。因此，掌握泛型编程思想对于现代程序员来说是非常重要的。



### 7.8 总结  

模板和泛型编程是C++中非常重要的概念，它们允许我们编写更加灵活和可重用的代码。通过掌握模板的基本语法和用法，我们可以创建出能够处理多种数据类型的函数和类。同时，通过利用STL等泛型编程库，我们可以提高代码的效率和质量。希望今天的讲解能够帮助大家深入理解C++中的模板和泛型编程。  

#### 7.8.1 模版学习达到目的

​	1） 看得懂代码；

​	2） 会使用别人写的模版代码

​	3） 会写简单的模版

​	4） 理解泛型思想（理解多少是多少），不畏惧此类代码

​	5） 迷上模版元编程和完全进入泛型的思想里。



### 7.9 练习题与进一步学习  

为了巩固今天的学习内容，布置几个练习题：  

1. 编写一个函数模板，用于交换两个任意类型变量的值。  (上面Swap重新一遍)

2. 编写一个类模板，用于创建一个固定大小的数组，并提供访问和修改元素的方法。  

   提示：尝试同时使用非类型模板参数和类型模板参数，参考上面普通类模版加上Factorial的示例

   ```
   template <typename T, int N>
   ```

   

3. 将我们之前学过的一个数据结构，尝试用模版的方式改写一下。

如果你想进一步深入学习模板和泛型编程，推荐阅读《C++模板元编程》，并多实践编写模板代码。通过不断练习和探索，你将逐渐掌握这些高级编程技术，并在实际项目中发挥它们的威力。  

